query = "shell"
max_size = 10
key_fields = ["name", "description", "keywords", "tags", "presentableFormat", "language"]
field_score = {
    "name": 1,
    "description": 0.5,
    "keywords": 0.5,
    "tags": 1,
    "presentableFormat": 0.25,
    "language": 2
}
response = [
    {
        'id': 3708,
        'name': 'Shell Sort',
        'description': '',
        'keywords': ['sort', 'shellsort', 'sortingalgo', 'python'],
        'tags': [],
        'presentableFormat': 'def shellSort(unsorted_arr):\n    gap = len(unsorted_arr) // 2\n    while gap > 0:\n        for i in range(gap, len(unsorted_arr)):\n            temp = unsorted_arr[i]\n            j = i\n# Sort the sub list for this gap\n    while j >= gap and unsorted_arr[j - gap] > temp:\n        unsorted_arr[j] = unsorted_arr[j - gap]\n        j = j-gap\n        unsorted_arr[j] = temp\n# Redu ce the gap for the next element\n    gap = gap//2\narr= [45,89,56,78,90,12,10,2,34,1]\nshellSort(arr)\nprint(arr)\n',
        'imports': [],
        'language': 'Python',
        'uses': 0,
        'averageRating': None,
        'comments': [],
        'commentsCount': 0,
        '__typename': 'AssistantRecipeWithStats',
        'term': '*'
    }, {'id': 10333,
        'name': 'eslint',
        'description': '',
        'keywords': [], 'tags': [],
        'presentableFormat': 'parser: espree\nenv:\n  amd: false\n  browser: false\n  es6: false\n  jasmine: false\n  jquery: false\n  meteor: false\n  mocha: false\n  node: false\n  phantomjs: false\n  prototypejs: false\n  shelljs: false\necmaFeatures:\n  arrowFunctions: false\n  binaryLiterals: false\n  blockBindings: false\n  classes: false\n  defaultParams: false\n  destructuring: false\n  forOf: false\n  generators: false\n  modules: false\n  objectLiteralComputedProperties: false\n  objectLiteralDuplicateProperties: false\n  objectLiteralShorthandMethods: false\n  objectLiteralShorthandProperties: false\n  octalLiterals: false\n  regexUFlag: false\n  regexYFlag: false\n  restParams: false\n  spread: false\n  superInFunctions: false\n  templateStrings: false\n  unicodeCodePointEscapes: false\n  globalReturn: false\n  jsx: false\nrules:\n  # Possible Errors\n  comma-dangle:\n    - 2\n    - never\n  no-comma-dangle: 0 # DEPRECATED\n  no-cond-assign: 2\n  no-console: 2\n  no-constant-condition: 2\n  no-control-regex: 2\n  no-debugger: 2\n  no-dupe-args: 2\n  no-dupe-keys: 2\n  no-duplicate-case: 2\n  no-empty-class: 2\n  no-empty: 2\n  no-ex-assign: 2\n  no-extra-boolean-cast: 2\n  no-extra-parens: 0\n  no-extra-semi: 2\n  no-func-assign: 2\n  no-inner-declarations:\n    - 2\n    - functions\n  no-invalid-regexp: 2\n  no-irregular-whitespace: 2\n  no-negated-in-lhs: 2\n  no-obj-calls: 2\n  no-regex-spaces: 2\n  no-reserved-keys: 0\n  no-sparse-arrays: 2\n  no-unreachable: 2\n  use-isnan: 2\n  valid-jsdoc: 0\n  valid-typeof: 2\n\n  # Best Practices\n block-scoped-var: 0\n  complexity:\n    - 0\n    - 11\n  consistent-return: 2\n  curly:\n    - 2\n    - all\n  default-case: 0\n  dot-notation:\n    - 2\n    - allowKeywords: true\n  eqeqeq: 2\n  guard-for-in: 0\n  no-alert: 2\n  no-caller: 2\n  no-div-regex: 0\n  no-else-return: 0\n  no-empty-label: 2\n  no-eq-null: 0\n  no-eval: 2\n  no-extend-native: 2\n  no-extra-bind: 2\n  no-fallthrough: 2\n  no-floating-decimal: 0\n  no-implied-eval: 2\n no-iterator: 2\n  no-labels: 2\n  no-lone-blocks: 2\n  no-loop-func: 2\n  no-multi-spaces: 2\n  no-multi-str: 2\n  no-native-reassign: 2\n  no-new-func: 2\n  no-new-wrappers: 2\n  no-new: 2\n  no-octal-escape: 2\n  no-octal: 2\n  no-param-reassign: 0\n  no-process-env: 0\n  no-proto: 2\n  no-redeclare: 2\n  no-return-assign: 2\n  no-script-url: 2\n  no-self-compare: 0\n  no-sequences: 2\n  no-throw-literal: 0\n  no-unused-expressions: 2\n  no-void: 0\n  no-warning-comments:\n    - 0\n    - terms:\n        - todo\n        - fixme\n        - xxx\n      location: start\n  no-with: 2\n  radix: 0\n  vars-on-top: 0\n  wrap-iife: 0\n  yoda:\n    - 2\n    - never\n\n  # Strict Mode\n  global-strict: # DEPRECATED\n    - 2\n    - never\n  no-extra-strict: 2 # DEPRECATED\n  strict: 2\n\n  # Variables\n  no-catch-shadow: 2\n  no-delete-var: 2\n  no-label-var: 2\n  no-shadow-restricted-names: 2\n  no-shadow: 2\n  no-undef-init: 2\n  no-undef: 2\n  no-undefined: 0\n  no-unused-vars:\n    - 2\n    - vars: all\n      args: after-used\n  no-use-before-define: 2\n\n  # Node.js\n  handle-callback-err: 0\n  no-mixed-requires:\n    - 0\n    - false\n  no-new-require: 0\n  no-path-concat: 0\n  no-process-exit: 2\n  no-restricted-modules: 0\n  no-sync: 0\n\n  # Stylistic Issues\n  brace-style:\n    - 0\n    - 1tbs\n  camelcase: 2\n  comma-spacing: 2\n  comma-style: 0\n  consistent-this:\n    - 0\n    - that\n  eol-last: 2\n  func-names: 0\n  func-style:\n    - 0\n    - declaration\n  indent: 0\n  key-spacing:\n    - 2\n    - beforeColon: false\n      afterColon: true\n  linebreak-style:\n    - 0\n    - unix\n  max-nested-callbacks:\n    - 0\n  - 2\n  new-cap: 2\n  new-parens: 2\n  newline-after-var: 0\n  no-array-constructor: 2\n  no-continue: 0\n  no-inline-comments: 0\n  no-lonely-if: 0\n  no-mixed-spaces-and-tabs:\n    - 2\n    - false\n  no-multiple-empty-lines:\n    - 0\n    - max: 2\n  no-nested-ternary: 0\n  no-new-object: 2\n  no-space-before-semi: 0 # DEPRECATED\n  no-spaced-func: 2\n  no-ternary: 0\n  no-trailing-spaces: 2\n  no-underscore-dangle: 2\n  no-unneeded-ternary: \n  no-wrap-func: 2\n  one-var: 0\n  operator-assignment:\n    - 0\n    - always\n  operator-linebreak: 0\n  padded-blocks: 0\n  quote-props: 0\n  quotes:\n    - 2\n    - double\n  semi-spacing:\n    - 2\n    - before: false\n      after: true\n  semi: 2\n  sort-vars: 0\n  space-after-function-name: # DEPRECATED\n    - 0\n    - never\n  space-after-keywords:\n    - 0\n    - always\n  space-before-blocks:\n    - 0\n    - always\n  space-before-function-paren:\n    - 0\n    - always\n  space-before-function-parentheses: # DEPRECATED\n    - 0\n    - always\n  space-in-brackets:\n    - 0\n    - never\n  space-in-parens:\n    - 0\n    - never\n  space-infix-ops: 2\n  space-return-throw-case: 2\n  space-unary-ops:\n    - 2\n    - words: true\n  nonwords: false\n  space-unary-word-ops: 0 # DEPRECATED\n  spaced-line-comment:\n    - 0\n    - always\n  wrap-regex: 0\n\n  # ECMAScript 6\n  generator-star-spacing: 0\n  generator-star: 0 # DEPRECATED\n  no-var: 0\n  object-shorthand: 0\n\n  # Legacy\n  max-depth:\n    - 0\n    - 4\n  max-len:\n    - 0\n    - 80\n    - 4\n  max-params:\n    - 0\n    - 3\n  max-statements:\n    - 0\n    - 10\n  no-bitwise: 0\n  no-plusplus: 0',
        'imports': [],
        'language': 'Yaml',
        'uses': 0, 'averageRating': None,
        'comments': [],
        'commentsCount': 0,
        '__typename': 'AssistantRecipeWithStats',
        'term': '*'},
    {'id': 10041,
     'name': 'BreakThePieces',
     'description': '',
     'keywords': [],
     'tags': [],
     'presentableFormat': 'function breakPieces(shape) {\n  const drawing = new Drawing(shape);\n  const vertices = drawing.vertices;\n\n  const graph = new Graph(vertices);\n  for (let i = 0; i < vertices.length-1; ++i) {\n    for (let j = i + 1; j < vertices.length; ++j) {\n      if (drawing.connected(vertices[i], vertices[j])) {\n        graph.connect(vertices[i], vertices[j]);\n      }\n    }\n  }\n  //console.log(graph);\n  const mcb = graph.minimumCycleBasis();\n  console.log(mcb.map(x => x.area))\n\n  return mcb.map(c => c.print());\n}\n\nclass Drawing {\n  constructor(str) {\n    this.drawing = str.split(\'\\n\').map(r => r.split(\'\'));\n    this.vertices = this.drawing.flatMap((row, i) =>\n      row.map((c, j) => c === \'+\' ? [i, j] : null).filter(Boolean)\n    );\n  }\n\n  connected(from, to) {\n    if (from[0] !== to[0] && from[1] !== to[1]) {\n      return false;\n    }\n    if (from[0] === to[0]) {\n      const line = this.drawing[from[0]].slice(from[1]+1, to[1]);\n      return !line.includes(\' \') && !line.includes(\'+\');\n    } else {\n      const line = this.drawing.map(r => r[from[1]]).slice(from[0]+1, to[0]);\n      return !line.includes(\' \') && !line.includes(\'+\');\n    }\n    return false;\n  }\n}\n\nclass Cycle {\n  constructor(vertices) {\n    this.vertices = vertices;\n    this.edges = this.getEdges();\n  }\n\n  independent(cycles) {\n    const edgesFound = {};\n  for (let e of this.edges) {\n      edgesFound[e] = false;\n      for (let cycle of cycles) {\n        for (let e0 of cycle.edges) {\n          if ((e0[0] === e[0] && e0[1] === e[1] ||\n              e0[0] === e[1] && e0[1] === e[0])) {\n            edgesFound[e] = true;\n          }\n        }\n  }\n    }\n    return Object.values(edgesFound).includes(false);\n  }\n\n  getEdges() {\n    let last = this.vertices[0];\n    const e = [];\n    for (let i = 1; i < this.vertices.length; ++i) {\n      e.push([last, this.vertices[i]]);\n      last = this.vertices[i];\n    }\n    return e;\n  }\n\n  get length() {\n    return this.vertices.length;\n  }\n\n  get area() {\n    const corners = this.cornerVertices().sort(([y0, x0], [y1, x1]) => {\n      if (y0 === y1) return x0 - x1;\n      return y0 - y1;\n    }).reduce((acc, [y, x]) => {\n      acc[y] = [...(acc[y] || []), [y, x]];\n      return acc;\n    }, {});\n    console.log(corners)\n  }\n\n  cornerVertices() {\n    const vertices = this.vertices.map(v => v.split(\',\').map(Number));\n    const corners = [vertices[0]];\n    for (let i = 1; i < vertices.length-1; ++i) {\n      const [y0, x0] = vertices[i-1];\n      const [y1, x1] = vertices[i];\n      const [y2, x2] = vertices[i+1];\n      if (y0 === y1 && y0 === y2 || x0 === x1 && x0 === x2) {\n        continue;\n      }\n      corners.push(vertices[i]);\n    }\n    corners.push(vertices[vertices.length-1]);\n    return corners;\n  }\n\n  print() {\n    const points = this.cornerVertices();\n    const minx = points.reduce((min, [y, x]) => x < min ? x : min, Infinity);\n    const miny = points.reduce((min, [y, x]) => y < min ? y : min, Infinity);\n    const maxx = points.reduce((max, [y, x]) => x > max ? x : max, 0);\n    const maxy = points.reduce((max, [y, x]) => y > max ? y : max, 0);\n    const sizey = maxy - miny + 1;\n    const sizex = maxx - minx + 1;\n    const shape = Array.from(Array(sizey), () => new Array(sizex).fill(\' \'));\n\n    let [y0, x0] = points[0];\n    for (let i = 1; i < points.length; ++i) {\n      const [y1, x1] = points[i];\n\n      if (y0 === y1) {\n        for (let x = Math.min(x0, x1); x <= Math.max(x0, x1); ++x) {\n          shape[y0-miny][x-minx] = \'-\';\n        }\n      } else if (x0 === x1) {\n        for (let y = Math.min(y0, y1); y <= Math.max(y0, y1); ++y) {\n          shape[y-miny][x0-minx] = \'|\';\n        }\n      }\n      [x0, y0] = [x1, y1];\n    }\n\n    for (let [y, x] of points) {\n      shape[y-miny][x-minx] = \'+\';\n    }\n\n    return shape.map(r => r.join(\'\')).join(\'\\n\');\n  }\n}\n\nclass Graph {\n  constructor(nodes) {\n    this.matrix = nodes.reduce((acc, node) => {\n      acc[node] = [];\n    return acc;\n    }, {});\n    this.nodes = nodes.map(n => n.toString());\n    this.edges = [];\n  }\n\n  connect(fr, to) {\n    this.matrix[fr].push(to.toString())\n    this.matrix[to].push(fr.toString());\n    this.edges.push([fr.toString(), to.toString()]);\n  }\n\n  minimumCycleBasis() {\n    /*\n    https://www.researchgate.net/publication/273471519_On_Computing_the_Translations_Norm_in_the_Epipolar_Graph#pf3\n    Horton algorithm - Find the minimum cycle basis (MCB)\n    Input: Biconnected graph G = (V, E)\n    Output: Minimum Cycle Basis B\n      1.  Find the shortest path P (x, y) between each pair of\n          vertices x, y â\x88\x88 V. Use Dijkstra\'s algorithm.\n      2.  for v â\x88\x88 V do\n            for (x, y) â\x88\x88 E do\n              Create the cycle C(v, x, y) = P (v, x) â\x88ª P (v, y) â\x88ª (x, y)\n              and calculate its length. De-generate cases in which P (v, x)\n              and P (v, y) have vertices other than v in common can be omitted.\n            end\n          end\n      3.  Order the cycles by increasing lengths.\n      4.  Initialize B = â\x88\x85. Add to B the next shortest cycle if it is independent\n          from the already selected ones.\n    */\n    const shortestDistances = this.shortestDistanceMatrix();\n\n    const cycles = [];\n    for (let node of this.nodes) {\n    for (let edge of this.edges) {\n        if (edge[0] === node || edge[1] === node) {\n          continue;\n        }\n        const path0 = [...shortestDistances[node][edge[0]]];\n        const path1 = [...shortestDistances[node][edge[1]]];\n        if (path0[0] !== node) path0.reverse();\n        if (path1[0] !== node) path1.reverse();\n        //console.log(node, edge, path0, path1)\n        if (path0.slice(1).findIndex(x => path1.slice(1).includes(x)) >= 0) {\n          continue;\n        }\n        const vertices = [...path0, ...path1.reverse()];\n        const cycle = new Cycle(vertices)\n        //console.log(cycle);\n        cycles.push(cycle);\n      }\n    }\n    cycles.sort((a, b) => a.length - b.length);\n\n    const cycleBasis = [];\n    for (let cycle of cycles) {\n      if (cycle.independent(cycleBasis)) {\n        cycleBasis.push(cycle);\n      }\n    }\n    return cycleBasis;\n  }\n\n  shortestDistanceMatrix() {\n    const shortestDistances = this.nodes.reduce((acc, node) => {\n      acc[node] = {};\n      return acc;\n    }, {});\n    for (let i = 0; i < this.nodes.length-1; ++i) {\n      for (let j = i; j < this.nodes.length; ++j) {\n        const fr = this.nodes[i];\n        const to = this.nodes[j];\n        if (fr === to) {\n          shortestDistances[fr][to] = [];\n        } else {\n          shortestDistances[fr][to] = this.shortestPathDijkstra(fr, to);\n          shortestDistances[to][fr] = [...shortestDistances[fr][to]].reverse();\n        }\n      }\n    }\n    return shortestDistances;\n  }\n\n  shortestPathDijkstra(start, end) {\n    if (!this.nodes.includes(start) || !this.nodes.includes(end)) {\n      return [];\n    }\n    const costs = {};\n    const parents = {};\n    const queue = new PriorityQueue();\n\n    this.nodes.forEach(node => {\n      costs[node] = Infinity\n    });\n    costs[start] = 0;\n\n    queue.enqueue([start, 0]);\n\n    while (!queue.isEmpty()) {\n      let shortestStep = queue.dequeue();\n      let currentNode = shortestStep[0];\n      if (currentNode === end) {\n        break;\n      }\n      this.matrix[currentNode].forEach(neighbor => {\n        let cost = costs[currentNode] + 1;\n        if (cost < costs[neighbor]) {\n          costs[neighbor] = cost;\n          parents[neighbor] = currentNode;\n          queue.enqueue([neighbor, cost]);\n        }\n      });\n    }\n\n    const path = [end];\n    let lastStep = end;\n    while (lastStep !== start) {\n      path.unshift(parents[lastStep])\n      lastStep = parents[lastStep]\n    }\n    return path;\n  }\n}\n\nclass PriorityQueue {\n  constructor() {\n    this.collection = [];\n  }\n\n  enqueue(element){\n    if (this.isEmpty()){ \n      this.collection.push(element);\n    } else {\n      let added = false;\n      for (let i = 1; i <= this.collection.length; i++){\n        if (element[1] < this.collection[i-1][1]){ \n          this.collection.splice(i-1, 0, element);\n          added = true;\n          break;\n        }\n      }\n      if (!added){\n        this.collection.push(element);\n      }\n    }\n  }\n\n  dequeue() {\n    const value = this.collection.shift();\n    return value;\n  }\n\n  isEmpty() {\n    return (this.collection.length === 0) \n  }\n}\n\nconst shape0 =\n  ["+------+-----+",\n  "|      |     |",\n  "|      |  |",\n  "+------+-----+"].join("\\n");\n\nconst shape1 =\n  ["+------------+",\n  "|            |",\n  "|            |",\n  "|            |",\n  "+------+-----+",\n  "|      |     |",\n  "|      |     |",\n  "+------+-----+"].join("\\n");\n\nconst shape2 =\n  ["    +---+",\n  "    |   |",\n  "+---+   |",\n  "|       |",\n  "+-------+"].join("\\n");\n\nconst shape3 =\n  ["    +---+     ",\n  "    |   +----+",\n  "+---+   +----+",\n  "|       |  ",\n  "+-------+     "].join("\\n");\n\nconst shape4 =\n["+-------------------+--+",\n  "|                   |  |",\n  "|                   |  |",\n  "|  +----------------+  |",\n  "|  |                   |",\n  "|  |                   |",\n  "+--+-------------------+"].join("\\n");\n\n//document.getElementById(\'sol0\').innerHTML = `<pre>${breakPieces(shape0).join(\'\\n\')}</pre>`;\n//document.getElementById(\'sol1\').innerHTML = `<pre>${breakPieces(shape1).join(\'\\n\')}</pre>`;\n//document.getElementById(\'sol2\').innerHTML = `<pre>${breakPieces(shape2).join(\'\\n\')}</pre>`;\ndocument.getElementById(\'sol3\').innerHTML = `<pre>${breakPieces(shape3).join(\'\\n\')}</pre>`;\n//document.getElementById(\'sol4\').innerHTML = `<pre>${breakPieces(shape4).join(\'\\n\')}</pre>`;\n',
     'imports': [],
     'language': 'Javascript',
     'uses': 0,
     'averageRating': None,
     'comments': [],
     'commentsCount': 0,
     '__typename': 'AssistantRecipeWithStats',
        'term': '*'
     }]
